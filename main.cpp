#include <napi.h>

// If you start trying to develop this project you need to look over additional include directories
// Under properties->C/C++->General->Additional includes

// You need CCO_s from monroecs - OPOS_CCOs_1.14.001
// Also need to yarn node_addon_api and include the path to the extra include directories where napi.h is located

// To use CCO_s you need ocx or dll files. First use the #import directive to generate a tlh file
// Then comment out the #import and #include the generated tlh file from the projects x64 directory

// Napi.h requires node_api.h which is usually located where your node version are kept
// Example path of node_api.h: C:\Users\power\AppData\Local\node-gyp\Cache\16.14.2\include\node
// Add the path to the projects extra include directories

// Also need node_addon_api from node_modules

// Node api also needs the library called node.lib which needs to be linked under properties->Linker->Input->Additional Dependencies
// The path for this lib for me was: C:\Users\power\AppData\Local\node-gyp\Cache\16.14.2\x64\node.lib (make sure to add the file with its extension not the directory)

// Example repo of a Scale and Scanner: https://github.com/datalogic/OPOSSamples
// Another example: https://github.com/microsoft/Windows-universal-samples/blob/main/Samples/BarcodeScanner/cpp/Scenario1_BasicFunctionality.xaml.cpp

#include "Oposdevicemanageratl_i.h" // Include the header file generated by your ATL project
#include "Oposdevicemanageratl_i.c"
#include <iostream>
#include <Windows.h>
#include <atlbase.h>
#include <atlcom.h>
#include <string>
#include <thread>
#include <mutex>
#include <queue>
#include <ctime>

// Map that ties commandID to a promise that needs resolving
#include <unordered_map>
std::unordered_map<std::string, std::shared_ptr<Napi::Promise::Deferred>> commandPromises;
std::mutex commandPromisesMutex;
// ------

std::queue<std::pair<std::string, std::string>> commandQueue;
std::mutex commandQueueMutex;

std::queue<std::string> completedCommands;
std::mutex completedCommandsMutex;

std::string GenerateUniqueCommandId(std::string command)
{
    time_t rawtime;
    struct tm *timeinfo;
    char buffer[80];

    time(&rawtime);
    timeinfo = localtime(&rawtime);

    strftime(buffer, sizeof(buffer), "%d%m%Y%H%M%S", timeinfo);
    std::string str(buffer);
    return command + "_" + str;
}

// Asynchronous poller(Busy waiting with inefficiency reducer system sleep)
// Every second the poller polls the mutexed(mutual exclusion) resource that marks down a completed command which has a promise waiting.
// Once the Execute method has polled a successful command it will move on to the OnOK function to use the necessary node enviroment reference to resolve the promise from a mutexed list of commandId - deferred(promise)
class CommandCompletionPoller : public Napi::AsyncWorker
{
public:
    CommandCompletionPoller(Napi::Env &env)
        : Napi::AsyncWorker(env), env_(env) {}

    void Execute()
    {
        while (true)
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // polling interval

            std::lock_guard<std::mutex> lock(completedCommandsMutex);
            if (!completedCommands.empty())
            {
                completedCommandId = completedCommands.front();
                completedCommands.pop();
                break;
            }
        }
    }

    void OnOK()
    {
        Napi::HandleScope scope(env_);

        std::lock_guard<std::mutex> lock(commandPromisesMutex);
        auto it = commandPromises.find(completedCommandId);
        if (it != commandPromises.end())
        {
            it->second->Resolve(Napi::String::New(env_, "Command completed: " + it->first));
            commandPromises.erase(it);
        }
    }

private:
    std::string completedCommandId;
    Napi::Env env_;
};

// MyDeviceManagerEvents is defined in the COM server EXE that is registered to the system registry. The blueprints for the com server come from the i.c and i.h file. These are events that are called by the COM server.
class CMyDeviceManagerEvents : public IMyDeviceManagerEvents
{
public:
    // OnDataEvent which is sent by the scanner sink on the server
    STDMETHODIMP OnDataEvent(BSTR data)
    {
        std::wcout << std::endl;
        std::wstring wstrData(data);
        std::wcout << L"Data event received: " << wstrData << std::endl;
        return S_OK;
    }

    // OnCommandComplete is sent each time a DoCommand command has been completed.
    STDMETHODIMP OnCommandCompleted(BSTR commandId)
    {
        std::wcout << std::endl;
        std::wstring wstrCommandId(commandId);
        std::string strCommandId(wstrCommandId.begin(), wstrCommandId.end());
        std::wcout << L"Command finished: " << wstrCommandId << std::endl;
        {
            std::lock_guard<std::mutex> lock(completedCommandsMutex);
            completedCommands.push(strCommandId);
        }

        return S_OK;
    }

    // Not yet implemented
    STDMETHODIMP OnErrorEvent(BSTR errorMessage)
    {
        std::wstring wstrErrorMessage(errorMessage);
        std::wcerr << L"Error event received: " << wstrErrorMessage << std::endl;
        return S_OK;
    }

    STDMETHODIMP_(ULONG)
    AddRef() override { return 1; }
    STDMETHODIMP_(ULONG)
    Release() override { return 1; }

    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObject) override
    {
        if (iid == IID_IUnknown || iid == IID_IMyDeviceManagerEvents)
        {
            *ppvObject = this;
            AddRef();
            return S_OK;
        }
        else
        {
            *ppvObject = NULL;
            return E_NOINTERFACE;
        }
    }
};

// Long lived process to set up a connection to the 32 bit opos COM server
// Requires the correct interface from the Opos server for connection points which this client connects to for event handling.
void comThreadFunction()
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        std::cerr << "Failed to initialize COM library." << std::endl;
        return;
    }

    CComPtr<IOposDeviceManager> spDeviceManager;
    hr = spDeviceManager.CoCreateInstance(__uuidof(OposDeviceManager));
    // ...

    // Create an instance of your event handler class
    CMyDeviceManagerEvents eventHandler;

    // Query the COM object for the IConnectionPointContainer interface
    CComPtr<IConnectionPointContainer> spCPC;
    hr = spDeviceManager->QueryInterface(IID_IConnectionPointContainer, (void **)&spCPC);

    // Find the connection point for the IMyDeviceManagerEvents interface
    CComPtr<IConnectionPoint> spCP;
    hr = spCPC->FindConnectionPoint(IID_IMyDeviceManagerEvents, &spCP);

    // Advise the connection point with the event handler object
    DWORD dwCookie;
    hr = spCP->Advise(&eventHandler, &dwCookie);

    // Run a loop to handle COM events and user commands
    MSG msg;
    while (true)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        std::pair<std::string, std::string> command;
        {
            std::lock_guard<std::mutex> lock(commandQueueMutex);
            if (!commandQueue.empty())
            {
                command = commandQueue.front();
                commandQueue.pop();
            }
        }

        if (!command.first.empty())
        {

            if (command.first == "stopScanner")
            {
                std::wstring wstrCommandId(command.second.begin(), command.second.end());
                BSTR commandId = SysAllocString(wstrCommandId.c_str());

                hr = spDeviceManager->StopScanner(commandId);
                SysFreeString(commandId);
                break;
            }
            else if (command.first == "enableDataEvents")
            {
                BSTR bstr = SysAllocString(L"device");

                std::wstring wstrCommandId(command.second.begin(), command.second.end());
                BSTR commandId = SysAllocString(wstrCommandId.c_str());

                hr = spDeviceManager->EnableDataEvent(bstr, commandId);
                SysFreeString(bstr);
                SysFreeString(commandId);
            }
            else if (command.first == "disableDataEvents")
            {
                BSTR bstr = SysAllocString(L"device");
                std::wstring wstrCommandId(command.second.begin(), command.second.end());
                BSTR commandId = SysAllocString(wstrCommandId.c_str());
                hr = spDeviceManager->DisableDataEvent(bstr, commandId);
                SysFreeString(bstr);
                SysFreeString(commandId);
            }
            else if (command.first == "startScanner")
            {
                std::wstring wstrCommandId(command.second.begin(), command.second.end());
                BSTR commandId = SysAllocString(wstrCommandId.c_str());

                hr = spDeviceManager->StartScanner(commandId);
                SysFreeString(commandId);
            }

            // Process the command and call the appropriate methods on the COM server
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    hr = spCP->Unadvise(dwCookie);

    CoUninitialize();
}

// Currently has been used as a failsafe against broken javascript calls to manipulate the scanner and to end the execution of the client
// A thread that waits for user input
void inputThreadFunction()
{
    std::string input;
    while (true)
    {
        std::getline(std::cin, input);

        if (input.empty())
        {
            continue;
        }

        std::lock_guard<std::mutex> lock(commandQueueMutex);
        commandQueue.push({input, GenerateUniqueCommandId(input)});

        if (input == "q")
        {
            break;
        }
    }
}

// DoCommand is called from JavaScript code. It accepts a string as a command.
// Each command received will be added to the promise list as a unique commandId and deffered(promise) pair.
// The deffered object has been made into a shared_ptr because of the lack of a default constructor for the Deffered napi object. This makes Cpp angry and won't let a typed pair with a Deffered napi object to exist.
// The command and commandId will be paired to be used in com server calls. The com server requires a commandId to notify the client via onCommandComplete that that command with a certain commandId has finished.
// Each call to DoCommand also starts a poller. Maximum amount of workers at once by default is 4. If there are too many requests to create pollers then pollers will be added to a queue which will start them
// once resources are available.
Napi::Promise DoCommand(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();
    std::string command = info[0].ToString().Utf8Value();
    std::string commandId = GenerateUniqueCommandId(command);

    std::shared_ptr<Napi::Promise::Deferred> deferred = std::make_shared<Napi::Promise::Deferred>(Napi::Promise::Deferred::New(env));

    {
        std::lock_guard<std::mutex> lock(commandPromisesMutex);
        commandPromises[commandId] = deferred;
    }

    // Enqueue the command along with the command ID
    {
        std::lock_guard<std::mutex> lock(commandQueueMutex);
        commandQueue.push({command, commandId});
    }

    // Start a command completion poller
    CommandCompletionPoller *worker = new CommandCompletionPoller(env);
    worker->Queue();

    return deferred->Promise();
}

// Starts a thread to start a connection to the 32 bit COM server and starts optional test based user input thread.
// Threads are detached to not block the node main thread. This is sensible since comThread is a very long lived process.
Napi::Promise StartMain(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();
    Napi::Promise::Deferred deferred = Napi::Promise::Deferred::New(env);

    try
    {
        std::thread comThread(comThreadFunction);
        std::thread inputThread(inputThreadFunction);

        // comThread.join();
        comThread.detach();
        // inputThread.join();
        inputThread.detach();
    }
    catch (const std::exception &e)
    {
        deferred.Reject(Napi::String::New(env, e.what()));
    }

    return deferred.Promise();
}

// Mapping of JavaScript functions to Cpp functions. Each Napi String will be called from javascript as addon.startMain() etc...
Napi::Object Init(Napi::Env env, Napi::Object exports)
{
    exports.Set(Napi::String::New(env, "startMain"),
                Napi::Function::New(env, StartMain));
    exports.Set(Napi::String::New(env, "doCommand"),
                Napi::Function::New(env, DoCommand));
    return exports;
}

NODE_API_MODULE(hello, Init)
